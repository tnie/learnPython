
python 学习笔记

以交互模式使用解释器，在输入多行指令时：
- 需要**多敲一次回车**（在显式上是 `...` 开始的空行）以表示**函数定义**结束。
- ~~如果是 print 输出多行字符，右括号表示结束~~ 博主的 [例子][2] 无法复现

## REPL

交互式开发环境：“读取-求值-输出”循环（英语：Read-Eval-Print Loop，简称REPL）

> REPL 对于学习一门新的编程语言具有很大的帮助，因为它能立刻对初学者做出回应。

注意区分命令行模式和交互模式：后者不能够执行 xx.py 文件；后者无需使用 `print` 就会打印语句的执行结果。

### 访问限制

python 在模块、类内部资源的访问限制上，使用下划线形式约定俗成，防君子不防小人
> 如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线 `__`

### 实例属性和类属性

实例属性，即 C++ 中的普通成员变量；给实例绑定属性有两种方式：
- 在构造方法 `__init__` 中通过 `self` 变量绑定
- 直接通过实例变量（可以任意绑定属性的）


类属性，即 C++ 中的静态成员变量；
- 直接在 `class` 中定义

和强类型约束的 C++ 相比：
- 在类定义之后，可以通过类名**动态**添加类数据属性，新增的类属性也被类和所有实例共有
- 在实例生成后，还可以**动态添加**实例数据属性，但是这些实例数据属性只属于该实例

#### 实例方法和类方法

- 实例方法：即 C++ 中普通成员函数， `foo(self, ...)`
- 类方法：即 C++ 中类的静态成员函数，需要使用 `@classmethod` 修饰， `fun(cls, ...)`
- 静态方法：即 C++ 中的自由函数（+约束在当前类名作用域中），需要使用 `@staticmethod ` 修饰

### 类也是对象

所以，访问类属性和类方法时也是通过 `类名.xx` 访问，而非 C++ 中 `类名::` 形式。

### 装饰器

装饰器的概念 `@log` `@perproty` `@xx.setter`
- 内置的 `@property` 装饰器就是负责把一个方法变成属性调用的
- `@property` 本身又创建了另一个装饰器 `@xx.setter`，负责把一个 `setter` 方法变成属性赋值

我认为博主对于装饰器的定义有误：
> 这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。

刚开始学习 python 时，不要去了解 decorator 是如何实现的，掌握它用来做什么、怎么使用就可以了。

### 传参

这是与 C++ 语言差别非常大的一点。

Python 中的**变量存放的都是对象引用**，所以 Python 的参数传递**只有引用传递** —— 造成函数内操作影响外部变量 —— 通过“不可变对象”避免这种混乱。

C++ 中对象存在 `mutable` 或 `const` 修饰；~~但在 Python 中，是否可变是不相同的两个类型。~~

对象赋值时，也只是创建了别名/引用。如果是“可变对象”，一改全改；如果是“不可变对象”，写时拷贝一份新的。

区分“不可变对象”和“可变对象”两个概念：似乎是通过类型区分（e.g. `list` 和 `tuple`），而非类型之外的修饰符:
- 不可变对象：`int`，`string`，`float`，`tuple`
- 可变对象 ：`list`，`dictionary`


>  定义默认参数要牢记一点：默认参数必须指向不变对象！

#### 创建不可变对象

正常定义一个类它的属性是可以正常访问和修改的，所以那些类的实例都是可变对象。

我们只要定义一个类，不允许它修改属性，就可以创建一个不可变对象。

#### 集合

常用的几个容器类型：dic `{}`  list `[]`  tuple`()`：
- 使用 `{}` 就创建了一个 dic 对象，字典
- 使用 `[]` 就创建了一个 list 对象，列表
- 使用 `()` 就创建了一个 tuple 对象，元组

> 要创建一个 set，需要提供一个 list 作为输入集合：`s = set([1, 2, 3])`


`for..in..` 循环，可用于什么类型？ `range()` 的结果不是 `list`，但其结果可以使用 `for..in..` 循环：`[x*x for x in range(10)]`

> 集合数据类型如 `list`、`dict`、`str` 等是 `Iterable` 但不是 `Iterator`，不过可以通过 `iter()` 函数获得一个 `Iterator` 对象。

`Iterator` 类型需要定义 `__next()__` 函数，以便 `next(it)`  返回下一个 `Iterator` 对象

初始的 `Iterator` 通过 `iter(obj)` 访问实现了 `__iter()__` 的类型获取：obj 即满足 `Iterable` 概念。obj 无需和 Iterator 类型相同。

- `type([])` is `list`;
- `type(iter([]))` is `list_iterator`;

#### 可变参数

#### 关键字参数

### 异步 IO 与协程

### generator 生成器

和迭代器的概念相关

> 跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。

> 如果一个函数定义中包含 `yield` 关键字，那么这个函数就不再是一个普通函数，而是一个 `generator`。而调用该函数就会生成一个 `generator` 对象

不同于常见的通过定义 class 描述类的属性和行为，此处通过包含 `yield` 关键字的函数也描述了某种类型，定义了它的行为。（推测此处通过函数封装了某个类的实现细节：在这个场景中，引入 `yield` 后通过函数描述更加清晰，且简洁 —— 结合 C++ 中使用 `switch` 模拟协程来理解，能够重入且能保存状态的函数）

使用两者创建对象的形式一致：`obj=cls()` 或 `obj=fun()`

> 这时 `func()` 并不会真正调用函数体，而是以函数体生成了一个生成器对象实例。

### 协程

协程的价值，是不是只有结合异步 IO 才能实现呢？包括本地磁盘 io，网络 io

大多数讲解 python 协程时 [举例生产者-消费者][3]，除去讲解 `yield` 如何使用外，没有任何实际意义。生产-消费-生产-消费-.... 的单一线程内循环没有任何实用价值：

- 如果以下代码能够解决问题，为什么要写协程？
- 如果以下代码无法解决问题，那例子中的协程也解决不了

```python
while True:
    producer()
    consumer()
```

我认为协程根本就不适用于生产-消费模型。欢迎来辩。

协程既然是一个线程执行，那如何利用多核 CPU 呢？最简单的方法是多进程 + 协程

### asyncio

## 工具

visual code 中调试 python，使用 Terminal 和 Python Interactive 有什么区别？为什么后者使用的 2.7.x 的环境？怎么修改？
- 选择解释器，会用于终端，但不会用于交互环境。
- https://github.com/Microsoft/vscode-python/issues/3579#issue-388444915

### 查看模块和函数的帮助文档

在 Python 的交互窗口中，使用 `print(对象.__doc__)` 或者 `help(包名.对象)`

# 问题

python 为什么不能把描述符放到实例的层次？（参考 c++，即类的普通成员，而非静态成员）

[1]:https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143178254193589df9c612d2449618ea460e7a672a366000
[2]:https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431658624177ea4f8fcb06bc4d0e8aab2fd7aa65dd95000
[3]:https://www.liaoxuefeng.com/wiki/1016959663602400/1017968846697824